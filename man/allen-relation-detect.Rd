% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/relation.R
\name{allen-relation-detect}
\alias{allen-relation-detect}
\alias{iv_detect_relation}
\title{Detect relations from Allen's Interval Algebra}
\usage{
iv_detect_relation(needles, haystack, ..., type, missing = "equals")
}
\arguments{
\item{needles}{\verb{[iv]}

Interval vectors used for relation matching.
\itemize{
\item Each element of \code{needles} represents the interval to search for.
\item \code{haystack} represents the intervals to search in.
}

Prior to comparison, \code{needles} and \code{haystack} are coerced to the same type.}

\item{haystack}{\verb{[iv]}

Interval vectors used for relation matching.
\itemize{
\item Each element of \code{needles} represents the interval to search for.
\item \code{haystack} represents the intervals to search in.
}

Prior to comparison, \code{needles} and \code{haystack} are coerced to the same type.}

\item{...}{These dots are for future extensions and must be empty.}

\item{type}{\verb{[character(1)]}

The type of relationship to find. See the Allen's Interval Algebra section
for a complete description of each type. One of:
\itemize{
\item \code{"precedes"}
\item \code{"preceded-by"}
\item \code{"meets"}
\item \code{"met-by"}
\item \code{"overlaps"}
\item \code{"overlapped-by"}
\item \code{"starts"}
\item \code{"started-by"}
\item \code{"during"}
\item \code{"contains"}
\item \code{"finishes"}
\item \code{"finished-by"}
\item \code{"equals"}
}}

\item{missing}{\verb{[logical(1) / "equals" / "error"]}

Handling of missing intervals in \code{needles}.
\itemize{
\item \code{"equals"} considers missing intervals in \code{needles} as exactly equal
to missing intervals in \code{haystack} when determining if there is a
matching relationship between them. Matched missing intervals in
\code{needles} result in a \code{TRUE} value in the result, and unmatched missing
intervals result in a \code{FALSE} value.
\item \code{"error"} throws an error if any intervals in \code{needles} are missing.
\item If a single logical value is provided, this represents the value returned
in the result for intervals in \code{needles} that are missing. You can force
missing intervals to be unmatched by setting this to \code{FALSE}, and you
can force them to be propagated by setting this to \code{NA}.
}}
}
\value{
A logical vector the same size as \code{needles}.
}
\description{
\code{iv_detect_relation()} is similar to \code{\link[=iv_detect_overlaps]{iv_detect_overlaps()}}, but it detects a
specific set of relations developed by James Allen in the paper:
\href{http://cse.unl.edu/~choueiry/Documents/Allen-CACM1983.pdf}{Maintaining Knowledge about Temporal Intervals}.
}
\section{Allen's Interval Algebra}{


The interval algebra developed by James Allen serves as a basis and
inspiration for \code{\link[=iv_locate_overlaps]{iv_locate_overlaps()}}, \code{\link[=iv_locate_precedes]{iv_locate_precedes()}}, and
\code{\link[=iv_locate_follows]{iv_locate_follows()}}. The original algebra is composed of 13 relations
which have the following properties:
\itemize{
\item Distinct: No pair of intervals can be related by more than one \code{type}.
\item Exhaustive: All pairs of intervals are described by one of the \code{type}s.
\item Qualitative: No numeric intervals are considered. The relationships are
computed by purely qualitative means.
}

Take the notation that \code{x} and \code{y} represent two intervals. Now assume that
\code{x} can be represented as \verb{[x_s, x_e)}, where \code{x_s} is the start of the
interval and \code{x_e} is the end of it. Additionally, assume that \code{x_s < x_e}.
With this notation, the 13 relations are as follows:
\itemize{
\item \emph{Precedes}:

\code{x_e < y_s}
\item \emph{Preceded-by}:

\code{x_s > y_e}
\item \emph{Meets}:

\code{x_e == y_s}
\item \emph{Met-by}:

\code{x_s == y_e}
\item \emph{Overlaps}:

\code{(x_s < y_s) & (x_e > y_s) & (x_e < y_e)}
\item \emph{Overlapped-by}:

\code{(x_e > y_e) & (x_s < y_e) & (x_s > y_s)}
\item \emph{Starts}:

\code{(x_s == y_s) & (x_e < y_e)}
\item \emph{Started-by}:

\code{(x_s == y_s) & (x_e > y_e)}
\item \emph{Finishes}:

\code{(x_s > y_s) & (x_e == y_e)}
\item \emph{Finished-by}:

\code{(x_s < y_s) & (x_e == y_e)}
\item \emph{During}:

\code{(x_s > y_s) & (x_e < y_e)}
\item \emph{Contains}:

\code{(x_s < y_s) & (x_e > y_e)}
\item \emph{Equals}:

\code{(x_s == y_s) & (x_e == y_e)}
}

Note that when \code{missing = "equals"}, missing intervals will only match
the \code{type = "equals"} relation. This ensures that the distinct property
of the algebra is maintained.
\subsection{Connection to other functions}{

Note that some of the above relations are fairly restrictive. For example,
\code{"overlaps"} only detects cases where \code{x} straddles \code{y_s}. It does not
consider the case where \code{x} and \code{y} are equal to be an overlap (as this
is \code{"equals"}) nor does it consider when \code{x} straddles \code{y_e} to be an
overlap (as this is \code{"overlapped-by"}). This makes the relations extremely
useful from a theoretical perspective, because they can be combined without
fear of duplicating relations, but they don't match our typical expectations
for what an "overlap" is.

\code{\link[=iv_locate_overlaps]{iv_locate_overlaps()}}, \code{\link[=iv_locate_precedes]{iv_locate_precedes()}}, and \code{\link[=iv_locate_follows]{iv_locate_follows()}} use
more intuitive \code{type}s that aren't distinct, but typically match your
expectations better. They can each be expressed in terms of Allen's
relations:
\itemize{
\item \code{iv_locate_overlaps()}:
\itemize{
\item \code{"any"}:

\code{overlaps | overlapped-by | starts | started-by | finishes | finished-by | during | contains | equals}
\item \code{"contains"}:

\code{contains | started-by | finished-by | equals}
\item \code{"within"}:

\code{during | starts | finishes | equals}
\item \code{"starts"}:

\code{starts | started-by | equals}
\item \code{"ends"}:

\code{finishes | finished-by | equals}
\item \code{"equals"}:

\code{equals}
}
\item \code{iv_locate_precedes()}:

\code{precedes | meets}
\item \code{iv_locate_follows()}:

\code{preceded-by | met-by}
}
}
}

\examples{
x <- iv(1, 3)
y <- iv(3, 4)

# `"precedes"` is strict, and doesn't let the endpoints match
iv_detect_relation(x, y, type = "precedes")

# Since that is what `"meets"` represents
iv_detect_relation(x, y, type = "meets")

# `"overlaps"` is a very specific type of overlap where an interval in
# `needles` straddles the start of an interval in `haystack`
x <- iv_pairs(c(1, 4), c(1, 3), c(0, 3), c(2, 5))
y <- iv(1, 4)

# It doesn't match equality, or when the starts match, or when the end
# of the interval in `haystack` is straddled instead
iv_detect_relation(x, y, type = "overlaps")
}
\seealso{
\link[=relation-locate]{Locating relationships}

\link[=allen-relation-locate]{Locating relations from Allen's Interval Algebra}

\link[=allen-relation-detect-parallel]{Detecting relations from Allen's Interval Algebra in parallel}
}
